<!DOCTYPE html>
<html>
<head>
    <title>Scrolling with j and k</title>
    <style>
        .inverted {
            color: #191724; /* Background color of Rose Pine theme for the inverted text */
            background-color: #FECB52; /* Text color of Rose Pine theme for the inverted text */
        }
        .center-div {
              display: flex;
  justify-content: center;
  align-items: center;
        }
        pre {
            font-size: 20px;
        }

        pre b, pre strong {
            font-weight: bold;
        }

        .cursor {
            color: #FECB52; /* Customize the cursor color */
        }
        /* Apply the Rose Pine color scheme to the background and text */
        body {
            overflow: hidden;
            background-color: #191724; /* Background color */
            color: #E9E1DD; /* Text color */
            font-family: Arial, sans-serif; /* Optional: Choose a suitable font-family */
        }

    </style>
    <title>SCP-6942-J</title>
</head>
<body>
    <div class="center-div">
    <pre id="text">
PROCEED WITH CAUTION: WE CANNOT VERIFY THE EDITOR THIS DOCUMENT WAS WRITTEN IN.
gggwGvG"+y

Item #: SCP-6942-J

Object Class: KETER-J

Special Containment Procedures: SCP-6942-J is to be contained in a locked,
soundproof room, accessible only by Level 5 personnel, and preferably located
as far away from the IT department as possible. Access to SCP-6942-J requires
written permission from the Site Director, a doctorate in memetics, and at
least three certifications in caffeine consumption. Unauthorized access to
SCP-6942-J may result in personnel believing they can code faster, leading to a
dangerous surplus of incomprehensible, spaghetti code in the Foundation's
systems.

Description: SCP-6942-J is a memetic entity known as "Vim" often referred to by
its followers as a "text editor." It poses a grave danger to any personnel who
are foolish enough to come into contact with it. Exposure to SCP-6942-J
invariably results in a profound delusion, in which the afflicted individual
becomes convinced that they can code at superhuman speeds, all while using
archaic, cryptic command-line interfaces.

Symptoms of Vim exposure include but are not limited to:

    1. A sudden, insatiable desire to replace normal text editors with
    SCP-6942-J in all work-related tasks, even those involving critical
    Foundation systems. 

    2. Uncontrollable muttering of incantations involving terms such as "I,"
    "A," "Esc," and "Kinesis," much to the confusion of their colleagues. 

    3. An irrational belief that a mouse is poison, navigating through
    codebases should look like "The Matrix," and modifying files faster than
    the terminal buffer can update is entirely possible.

Despite the subject's actual coding abilities remaining at their pre-exposure
level, they will assert that their coding abilities have improved. They may
engage in heated arguments, insisting that Vim is the only true way to
code. These debates invariably lead to a severe degradation of workplace
productivity and strained relationships among Foundation personnel.

Efforts to deprogram Vim-affected individuals have thus far proven futile, as
they remain committed to their key-binding delusions. In some extreme cases,
they have resorted to forming underground "cults" dedicated to spreading the
"teachings" of Vim, leading to potential breaches.

Addendum - Incident Log 6942-J-1: In one unfortunate incident, a Level 3
researcher exposed to SCP-6942-J managed to convince an entire IT department
that Vim was the future of coding. They attempted to replace the Foundation's
entire data management system with macros, lua, and vim script. Chaos ensued,
and containment breaches were narrowly avoided.

Addendum - Incident Log 6942-J-2: During a containment breach, an affected
personnel tried to fend off a hostile SCP with a barrage of frantic Vim
keystrokes, only to accidentally delete critical security infrastructure. The
entity temporarily gained access to several sensitive areas within the
facility. Thankfully, it was recaptured, but not before causing considerable
damage.

Addendum - Incident Log 6942-J-3: The "Vim/Emacs War"

Over time, the memetic entity SCP-6942-J, commonly known as "Vim," has created
a significant conflict within the Foundation community known as the "Vim/Emacs
War." This war emerged as followers of Vim and its rival, the equally memetic
"Emacs," engaged in an ideological battles that threatened the very fabric of
the Foundation. The war raged on with no apparent end in sight, until the
emergence of a new faction known as "Doom Emacs" appeared.

Doom Emacs, an enigmatic group, rose to prominence among the afflicted Emacs
users. They claimed to have found a superior way to harness the power of Emacs
while retaining the efficiency of Vim, thus declaring a ceasefire in the
Vim/Emacs War. Their manifesto, titled "The Covenant of Doom," although
focussed on free and open source software, managed to quell some of the
internal conflicts within the Foundation, uniting disgruntled Emacs and Vim
victims.

However, a new twist occurred when the entity known as "Neovim" began to gain
prominence within the afflicted Vim users. Neovim's followers claimed that it
was the true messiah, the savior of Vim, and the harbinger of a new age of
coding efficiency. Their emergence has reignited the Vim/Emacs War, which had
been at a stalemate since the rise of Doom Emacs.

Surprisingly, the Foundation has extended limited support to the Neovim
movement, as some personnel believe that the resurgence of Vim may be the key
to ultimately defeating the Emacs entity. This tactical support includes
providing access to resources and funding for research and development efforts
related to Neovim. The goal is to maintain the chaos within the Emacs faction
and eventually exploit their internal divisions to neutralize the Emacs memetic
entity entirely.

As of 2023-10-22, the war continues to be a threat to productivity and sanity
within the Foundation, and ongoing containment measures are crucial.

Addendum - Incident Log 6942-J-4: The "VSCode Conflict"

A new conflict has erupted within the Foundation's coding community. This time,
the battlefront is centered around the increasingly popular Integrated
Development Environment (IDE) known as VSCode. The VSCode conflict has pitted
the traditional Vim puritans against a rapidly growing sect within the
Foundation that has adopted VSCode with Vim bindings.

The Vim puritans, known for their unwavering devotion to the cryptic CLI
Vim and now Neovim, have opposed the rise of VSCode with Vim bindings. They
argue that such an abomination of an IDE cannot be a true ally of Vim. They
firmly believe that only by diving headfirst into Vim's command-line interface
can one attain true coding enlightenment. This group, led by the
self-proclaimed "Vimeagen," has attempted to convert or expel any Foundation
personnel found using VSCode with Vim bindings.

On the other side of this war are the proponents of VSCode with Vim bindings, a
sect that has been steadily growing in numbers. They contend that the added
convenience of VSCode's modern interface, paired with the familiarity of Vim
keybindings, provides the best of both worlds. Their leader, who goes by the
moniker "Melkey," claims that this fusion results in a superior coding
experience and leads to increased productivity.

The clash between these two factions has led to heated debates about
keyboard shortcut and even a series of memetic "code-offs" that
often devolved into memory-leaks even when using a borrow checker. The Foundation's
productivity, already compromised by the ongoing Vim-Emacs conflict, has
further deteriorated due to this internal struggle.

Remarkably, the Foundation has chosen not to take sides in this battle, as it
views the VSCode conflict as an internal matter. The logic behind this approach
is the belief that the war between Vim puritans and the VSCode with Vim
bindings sect will ultimately weaken both sides, which may serve the
Foundation's interests by preventing any single coding ideology from
dominating. 

Nonetheless, containment procedures for SCP-6942-J have been adapted to account
for the new conflict. Personnel are encouraged to use the coding tools they
find most effective, as long as they do not compromise sensitive data or
mention the Rust Foundation. The situation remains fluid, and the VSCode
conflict is monitored closely to assess its impact on Foundation
operations.

SCP-6942-J is a dangerous memetic entity that deludes individuals into thinking
they can code faster, often with catastrophic consequences. All personnel are
strongly advised to avoid any exposure to this entity, and any personnel
already affected should be kept far away from any computer systems.
Additionally, all copies of Vim and text written in Vim are to be stored in
secure, soundproof containers, accessible only by personnel with the highest
security clearances and an immunity to its effects.

:wq


    </pre>
    </div>
<script>
        const preElement = document.getElementById('text');
        let cursorPosition = 0;

        function updateCursorPosition() {
            const text = preElement.textContent;
            const beforeIndex = text.substring(0, cursorPosition);
            const charAtIndex = text.charAt(cursorPosition);
            const afterIndex = text.substring(cursorPosition+ 1);
            
            preElement.innerHTML = beforeIndex + `<span class="inverted">${charAtIndex}</span>` + afterIndex;
        }



        function move_forward(count) {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            while (charAtIndex != '\n' && cursorPosition < text.length && count >= 0){
                cursorPosition += 1;
                count -= 1;
                charAtIndex = text.charAt(cursorPosition);
            }
        }

        function move_back(count) {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            while (charAtIndex != '\n' && cursorPosition >= 0 && count >= 0){
                cursorPosition -= 1;
                count -= 1;
                charAtIndex = text.charAt(cursorPosition);
            }
        }

        function to_newline() {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            let count = 0;
            while (charAtIndex != '\n' && cursorPosition < text.length){
                cursorPosition += 1;
                count += 1;
                charAtIndex = text.charAt(cursorPosition);
            }
            return count;
        }

        function back_to_newline() {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            let count = 0;
            while (charAtIndex != '\n' && cursorPosition >= 0){
                cursorPosition -= 1;
                count += 1;
                charAtIndex = text.charAt(cursorPosition);
            }
            return count;
        }

        function skip_lines_forward() {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            while (charAtIndex == '\n' && cursorPosition < text.length){
                cursorPosition += 1;
                charAtIndex = text.charAt(cursorPosition);
            }
        }

        function skip_lines_back() {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            while (charAtIndex == '\n' && cursorPosition >= 0){
                cursorPosition -= 1;
                charAtIndex = text.charAt(cursorPosition);
            }
        }
        function back_skip_space() {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            while (charAtIndex == ' ' && cursorPosition >= 0){
                cursorPosition -= 1;
                charAtIndex = text.charAt(cursorPosition);
            }
        }
        function skip_space() {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            while (charAtIndex == ' ' && cursorPosition < text.length){
                cursorPosition += 1;
                charAtIndex = text.charAt(cursorPosition);
            }
        }

        function back_skip_word() {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            while (charAtIndex != ' ' && cursorPosition >= 0){
                cursorPosition -= 1;
                charAtIndex = text.charAt(cursorPosition);
            }
            back_skip_space();
            cursorPosition -= 1;
            charAtIndex = text.charAt(cursorPosition);
            while (charAtIndex != ' ' && cursorPosition >= 0){
                cursorPosition -= 1;
                charAtIndex = text.charAt(cursorPosition);
            }
            skip_space();
        }

        function skip_word() {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            while (charAtIndex != ' ' && cursorPosition < text.length){
                cursorPosition += 1;
                charAtIndex = text.charAt(cursorPosition);
            }
            skip_space();
        }
        function find_last_char(char) {
            let idx = cursorPosition-1;
            const text = preElement.textContent;
            let charAtIndex = text.charAt(idx);
            while (charAtIndex != char && idx >= 0){
                idx -= 1;
                charAtIndex = text.charAt(idx);
            }
            if(charAtIndex==char) {
                cursorPosition = idx;
            }
            skip_space();
        }

        function find_next_char(char) {
            let idx = cursorPosition+1;
            const text = preElement.textContent;
            let charAtIndex = text.charAt(idx);
            while (charAtIndex != char && idx< text.length){
                idx += 1;
                charAtIndex = text.charAt(idx);
            }
            if(charAtIndex==char) {
                cursorPosition = idx;
            }
            skip_space();
        }

        let last_pos = 0;
        let was_g_last = false;
        let was_f_last = false;
        let was_F_last = false;

        function updateScrollPosition() {
            const text = preElement.textContent;
            let charAtIndex = text.charAt(cursorPosition);
            let count = 0;
            for (let i = 0; i < cursorPosition; i++) {
                charAtIndex = text.charAt(i);
                if(charAtIndex == '\n') {
                    count += 1;
                }
            }
            window.scrollBy(0, (count - last_pos) * 20); // Scroll down 50 pixels
            last_pos = count;
        }

        function is_number(key) {
            let is_number = true;
            switch (key) {
                case '0':
                    break;
                case '1':
                    break;
                case '2':
                    break;
                case '3':
                    break;
                case '4':
                    break;
                case '5':
                    break;
                case '6':
                    break;
                case '7':
                    break;
                case '8':
                    break;
                case '9':
                    break;
                default:
                    is_number = false;
            }
            return is_number;
        }
        let str_num = "";

        updateCursorPosition();

        document.addEventListener('keydown', function(e) {
            const text = preElement.textContent;
            let count = 0;
            let repeat = 1;
            let key = e.key;
            let add_num = true;
            if(was_f_last && key!="Shift"){
                find_next_char(key);
                repeat = 0;
                was_f_last = false;
                add_num = false;
            }
            if(was_F_last && key!="Shift"){
                find_last_char(key);
                repeat = 0;
                was_F_last = false;
                add_num = false;
            }
            if(is_number(key) && add_num){
                str_num = str_num + key;
            } else if(add_num==false || was_F_last || was_f_last) {
                //do nothing
            } else {
                if(key=="Escape"){
                    str_num = "";
                    was_F_last = false;
                    was_f_last = false;
                    was_g_last = false;
                    repeat = 0;
                }
                if(str_num!=""){
                    repeat = Number(str_num);
                }
                if(key=='g'){
                    if(was_g_last) {
                        cursorPosition = 0;
                        repeat = 0;
                    } else {
                        was_g_last = true;
                    }
                } else {
                    was_g_last = false;
                }
                if(key=='G') {
                    cursorPosition = text.length -1;
                    repeat = 0;
                }
                if(key=='f') {
                    was_f_last = true;
                }
                if(key=='F') {
                    was_F_last = true;
                }
                for(let i = 0; i < repeat; i++){
                    switch (key) {
                        case 'h':
                            if (cursorPosition > 0) {
                                cursorPosition--;
                            }
                            break;
                        case 'j':
                            count = back_to_newline();
                            skip_lines_forward();
                            to_newline();
                            skip_lines_forward();
                            move_forward(count-2);
                            skip_lines_back();
                            break;
                        case 'k':
                            count = back_to_newline();
                            skip_lines_back();
                            back_to_newline();
                            skip_lines_forward();
                            if (cursorPosition < 80) {
                                move_forward(count-1);
                            } else {
                                move_forward(count-2);
                            }
                            skip_lines_back();
                            break;
                        case 'l':
                            if (cursorPosition < preElement.textContent.length) {
                                cursorPosition++;
                            }
                            break;
                        case 'w':
                            skip_word();
                            break;
                        case 'b':
                            back_skip_word();
                            break;
                    }
                }
                str_num = "";
            }

            updateScrollPosition();
            updateCursorPosition();
        });
    </script>
</body>
</html>
